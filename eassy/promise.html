<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>promise解析 |  </title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/head.jpg">
    <script>
              var _hmt = _hmt || [];
              (function() {
                  var hm = document.createElement("script");
                  hm.src = "https://hm.baidu.com/hm.js?850788452cf34b7fc456bd7e8a437504";
                  var s = document.getElementsByTagName("script")[0];
                  s.parentNode.insertBefore(hm, s);
              })();
            </script>
    <meta name="description" content=" ">
    <link rel="preload" href="/assets/css/0.styles.a6ddf5cf.css" as="style"><link rel="preload" href="/assets/js/app.32b1937c.js" as="script"><link rel="preload" href="/assets/js/2.1166114f.js" as="script"><link rel="preload" href="/assets/js/16.7de35f5a.js" as="script"><link rel="prefetch" href="/assets/js/10.ac0d171d.js"><link rel="prefetch" href="/assets/js/11.a59accf0.js"><link rel="prefetch" href="/assets/js/12.20fbf770.js"><link rel="prefetch" href="/assets/js/13.623743ff.js"><link rel="prefetch" href="/assets/js/14.2ffaae32.js"><link rel="prefetch" href="/assets/js/15.52ffd5da.js"><link rel="prefetch" href="/assets/js/17.e8b20196.js"><link rel="prefetch" href="/assets/js/18.4bede55e.js"><link rel="prefetch" href="/assets/js/19.c28349e6.js"><link rel="prefetch" href="/assets/js/20.cc3f96fa.js"><link rel="prefetch" href="/assets/js/21.aeba0d84.js"><link rel="prefetch" href="/assets/js/22.5f2a46d0.js"><link rel="prefetch" href="/assets/js/23.7d0dacf0.js"><link rel="prefetch" href="/assets/js/24.650d8f6a.js"><link rel="prefetch" href="/assets/js/25.b923c43d.js"><link rel="prefetch" href="/assets/js/26.38ce26e1.js"><link rel="prefetch" href="/assets/js/27.183413b7.js"><link rel="prefetch" href="/assets/js/28.13ae56af.js"><link rel="prefetch" href="/assets/js/3.a4b6be5c.js"><link rel="prefetch" href="/assets/js/4.609dba14.js"><link rel="prefetch" href="/assets/js/5.802a929c.js"><link rel="prefetch" href="/assets/js/6.659d72aa.js"><link rel="prefetch" href="/assets/js/7.5fb965ee.js"><link rel="prefetch" href="/assets/js/8.05a4f516.js"><link rel="prefetch" href="/assets/js/9.129b8c02.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a6ddf5cf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name"> </span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/index.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/作品/" class="nav-link">
  作品
</a></div><div class="nav-item"><a href="/eassy/" class="nav-link router-link-active">
  文章
</a></div><div class="nav-item"><a href="/随笔/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://github.com/cc456xie" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/index.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/作品/" class="nav-link">
  作品
</a></div><div class="nav-item"><a href="/eassy/" class="nav-link router-link-active">
  文章
</a></div><div class="nav-item"><a href="/随笔/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://github.com/cc456xie" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>eassy</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/eassy/6.22.html" class="sidebar-link">第一次作业</a></li><li><a href="/eassy/ECMA2015+.html" class="sidebar-link">ES6+</a></li><li><a href="/eassy/FP.html" class="sidebar-link">函数式编程从入门到出家</a></li><li><a href="/eassy/" aria-current="page" class="sidebar-link">HTTP初探</a></li><li><a href="/eassy/bfc.html" class="sidebar-link">BFC探究</a></li><li><a href="/eassy/cx-tools-library.html" class="sidebar-link">工具函数库文档</a></li><li><a href="/eassy/handle-promise.html" class="sidebar-link">手写promise以及其部分方法</a></li><li><a href="/eassy/promise.html" aria-current="page" class="active sidebar-link">promise解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eassy/promise.html#描述" class="sidebar-link">描述</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#特点" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#基本用法" class="sidebar-link">基本用法</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-prototype-then" class="sidebar-link">promise.prototype.then()</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-prototype-finally" class="sidebar-link">Promise.prototype.finally()</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-all" class="sidebar-link">promise.all()</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-race" class="sidebar-link">promise.race()</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-allsettled" class="sidebar-link">Promise.allSettled()</a></li><li class="sidebar-sub-header"><a href="/eassy/promise.html#promise-any" class="sidebar-link">Promise.any()</a></li></ul></li><li><a href="/eassy/serverless.html" class="sidebar-link">serverless-大前端的思考</a></li><li><a href="/eassy/sort.html" class="sidebar-link">手撕排序算法(上)</a></li><li><a href="/eassy/typescript入门.html" class="sidebar-link">typescript</a></li><li><a href="/eassy/前端工程化及及自动化构建.html" class="sidebar-link">/eassy/前端工程化及及自动化构建.html</a></li><li><a href="/eassy/手写call,apply,bind.html" class="sidebar-link">手写 call，apply，bind</a></li><li><a href="/eassy/手写节流、防抖.html" class="sidebar-link">手写节流，防抖</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise解析"><a href="#promise解析" class="header-anchor">#</a> promise解析</h1> <h2 id="描述"><a href="#描述" class="header-anchor">#</a> 描述</h2> <p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p> <p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <h2 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h2> <p>Promise对象有以下两个特点。</p> <p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p> <p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p> <p>Promise也有一些缺点。首先，<strong>无法取消Promise</strong>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<strong>Promise内部抛出的错误，不会反应到外部</strong>。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> <h2 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h2> <p>ES6 规定 ，Promise对象是一个构造函数，用来生成Promise实例。</p> <p>下面代码创造了一个Promise实例。</p> <div class="language- extra-class"><pre class="language-text"><code>   const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

</code></pre></div><p><strong>Promise构造函数</strong>接受一个函数作为参数，该函数的两个参数分别是<strong>resolve</strong>和<strong>reject</strong>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p> <p><strong>resolve函数</strong>的作用是，将Promise对象的状态从“<strong>未完成</strong>”变为“<strong>成功</strong>”（即从 <strong>pending</strong> 变为 <strong>resolved</strong>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“<strong>未完成</strong>”变为“<strong>失败</strong>”（即从 <strong>pending</strong> 变为 <strong>rejected</strong>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <hr> <p>Promise实例生成以后，可以用<strong>then</strong>方法分别指定resolved状态和rejected状态的<strong>回调函数</strong>:</p> <div class="language- extra-class"><pre class="language-text"><code>promise.then(function(value) {
  // success
}, function(error) {
  // failure
});

</code></pre></div><p><strong>then</strong>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p> <hr> <h2 id="promise-prototype-then"><a href="#promise-prototype-then" class="header-anchor">#</a> promise.prototype.then()</h2> <p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象<strong>Promise.prototype</strong>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p> <p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p> <h3 id="then的链式调用"><a href="#then的链式调用" class="header-anchor">#</a> then的链式调用:</h3> <div class="language- extra-class"><pre class="language-text"><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function (comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function (err){
  console.log(&quot;rejected: &quot;, err);
});

</code></pre></div><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p> <h3 id="一个-promise-就是一个对象，它代表了一个异步操作的最终完成或者失败。"><a href="#一个-promise-就是一个对象，它代表了一个异步操作的最终完成或者失败。" class="header-anchor">#</a> 一个 Promise 就是一个对象，它代表了一个异步操作的最终完成或者失败。</h3> <p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});

</code></pre></div><p>上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。</p> <h2 id="promise-prototype-finally"><a href="#promise-prototype-finally" class="header-anchor">#</a> Promise.prototype.finally()</h2> <p>**finally()**方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p> <div class="language- extra-class"><pre class="language-text"><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});

</code></pre></div><h2 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> promise.all()</h2> <p>**Promise.all()**方法用于将多个 Promise 实例，包装成一个新的 Promise 实例.</p> <div class="language- extra-class"><pre class="language-text"><code>const p = Promise.all([p1, p2, p3]);

</code></pre></div><p>上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p> <p>p的状态由p1、p2、p3决定，分成两种情况。</p> <p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p> <p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p> <h2 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> promise.race()</h2> <p>**Promise.race()**方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>const p = Promise.race([p1, p2, p3]);

</code></pre></div><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p> <p>Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。</p> <h2 id="promise-allsettled"><a href="#promise-allsettled" class="header-anchor">#</a> Promise.allSettled()</h2> <p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装</p> <p>实例才会结束。该方法由 ES2020 引入。</p> <div class="language- extra-class"><pre class="language-text"><code>const promises = [
  fetch('/api-1'),
  fetch('/api-2'),
  fetch('/api-3'),
];

await Promise.allSettled(promises);
removeLoadingIndicator();

</code></pre></div><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p> <h2 id="promise-any"><a href="#promise-any" class="header-anchor">#</a> Promise.any()</h2> <p>Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。</p> <p>Promise.any()跟Promise.race()方法很像，只有一点不同，<strong>就是不会因为某个 Promise 变成rejected状态而结束</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>const promises = [
  fetch('/endpoint-a').then(() =&gt; 'a'),
  fetch('/endpoint-b').then(() =&gt; 'b'),
  fetch('/endpoint-c').then(() =&gt; 'c'),
];
try {
  const first = await Promise.any(promises);
  console.log(first);
} catch (error) {
  console.log(error);
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/eassy/handle-promise.html" class="prev">
        手写promise以及其部分方法
      </a></span> <span class="next"><a href="/eassy/serverless.html">
        serverless-大前端的思考
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.32b1937c.js" defer></script><script src="/assets/js/2.1166114f.js" defer></script><script src="/assets/js/16.7de35f5a.js" defer></script>
  </body>
</html>
